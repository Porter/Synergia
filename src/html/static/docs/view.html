<!doctype html>
<html>
	<head>
		<title>Connectivity</title>
		<script type="text/javascript" src="/public/js/socket.io-1.2.0.js"></script>
		<script type="text/javascript" src="/public/js/jquery-1.11.1.js"></script>
		<script type="text/javascript" src="/public/bootstrap/js/bootstrap.min.js"></script>
		<script type="text/javascript" src="/public/js/change.js"></script>
		<script type="text/javascript" src="/public/js/tinycolor.js"></script>
		<script src="/public/js/angular.min.js"></script>
		
		<link href="/public/bootstrap/css/bootstrap.min.css" rel="stylesheet">
	</head>
	


<style>
		body {
			background: rgb(15,4,87);
		}
	
	.title {
		font-size: 24px;
		font-family:"Courier";
		font-weight: bold;
		padding-bottom: none;
		color:white;
	}

	#leftBar {
		width:50%;
		margin-left:25%;
		margin-top: 25vh;
		height: 60vh;
		background-color: rgb(255, 255, 255);
		border-radius: 15px;
		border:3px dotted rgb(51, 133, 51);
		font-family: "Courier";
		font-size: 15px;
		font-weight: bold;
		text-align: center;
	}

	#leftBar > ul {
		list-style-type: none;
		margin-top: 20px;
		padding-left:0;
	}
	
	#main {
		height: 85vh;
		
	}
	#mainContent {
		position: fixed;
		top: 0;
		left: 0;
		padding: 0;
		height: 100px;
		width: 0px;
		overflow-y: hidden;
		outline: none;
		font-size: 24px;
		background-color: #fff;
		nothing: rgb(255, 246, 211);
		border-radius: 0px;
		border: none;
		resize: none;
	}

	#testArea {
		background-color:rgb(255, 255, 255);
		height: 100vh;
		z-index: -1;
		font-size: 18px;
		font-family: "Courier";
		padding-left: 20px;
		padding-top: 15px;
		border: 4px solid rgb(51, 133, 51);
		border-radius:20px;
		margin-top:2vh;
		overflow: scroll;
	}
	
	
	
	#people li{
		display: inline;
	}
	
	.row {
		width:100%;
	}
	
	#rightBar {
		position: fixed;
		top: 30vh;
		right: 0;
		height: 30vh;
		width: 20%;
		background-color: rgb(245, 193, 124);
	}
	
	
	#middleBar {
		position: fixed;
		top: 30vh;
		right: 0;
		height: 30vh;
		width: 25%;
		background-color: rgb(150, 108, 67);
	}
	
	#middleBar *,  #middleBarBack *{
		position: relative;
		top: .3vh;
		padding-right: 15px;
		font-size: 18px;
		font-family: Tahoma;
		color: rgb(255, 204, 153);
		height: 25%;
		text-align: right;	
		border: none;
	}
	
	#middleBarBack {
		position: fixed;
		top: 35vh;
		right: 0;
		height: 30vh;
		width: 100%;
		z-index: -1;
	}
	
	#status{
		text-align: right;
		padding-right: 4em;
		padding-top: 15px;
		font-size: 18px;
		font-family: Tahoma;
		color: rgb(25, 89, 25);
	}

	.kix-cursor {
	  cursor: text;
	  position: absolute;
	  z-index: 24;
	}
	

	.kix-cursor-caret {
	  position: absolute;
	  width: 0px;
	  border-left: 2px solid;
	  font-size: 0;
	}

	.kix-cursor-top {
	  position: absolute;
	  width: 6px;
	  left: -2px;
	  top: -2px;
	  height: 6px;
	  font-size: 0;
	}
	

	.kix-cursor-name {
	  position: absolute;
	  font-size: 10px;
	  color: #fff;
	  top: -14px;
	  left: -2px;
	  padding: 2px;
	  white-space: nowrap;
	}

	#main {
		position: relative;
	}

	.wrapword{
		white-space: -moz-pre-wrap !important;  /* Mozilla, since 1999 */
		white-space: -pre-wrap;      /* Opera 4-6 */
		white-space: -o-pre-wrap;    /* Opera 7 */
		white-space: pre-wrap;       /* css-3 */
		word-wrap: break-word;       /* Internet Explorer 5.5+ */
		white-space: -webkit-pre-wrap; /* Newer versions of Chrome/Safari*/
		word-break: break-all;
		white-space: normal;

		}
	
	
	
		</style>

	
	<body>

		<div ng-app="myApp" ng-controller="myController">

		<nav class="navbar navbar-inverse navbar-static-top">
			<div class="container-fluid">
				<!-- Brand and toggle get grouped for better mobile display -->
				<div class="navbar-header">
					<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
						<span class="sr-only">Toggle navigation</span>
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
					</button>
					<ul class="nav navbar-nav">
						<li class="navbar-brand">
							<a style="top:-15px" href="/">HOME PAGE</a>
						</li>
					</ul>
				</div>
				
				<!-- Collect the nav links, forms, and other content for toggling -->
				<div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
					
					<ul class="nav navbar-nav navbar-right" style="margin-right: 5%">
						<li><a href="/profile?user={{userId}}">{{ username }}</a></li>
						<li><a href="/logout">Sign out</a></li>
					</ul>
					
				</div><!-- /.navbar-collapse -->
			</div><!-- /.container-fluid -->
		</nav>

		<div id="status" style="position: fixed; width: 50px; height: 50px; right: 0px; top 50px; background-color:green; display:none"></div>
		
		<div class="row">
			<div class="col-xs-4">
				<div id="leftBar">
					<center>
						<button id="notify" onclick="notify(this)">notify</button>
						<button id="cancel" onclick="cancelNotify(this)" style="display:none">cancel</button>
					</center>
					<ul id="leftBarUlActive"></ul>

					<hr style="cursor:ns-resize" />

					<ul id="leftBarUlNotActive"></ul>
					
					<hr style="cursor:ns-resize" />
					
					<ul id="customEmails"></ul>
					<div id="addEmail" style="display:none">
						<div class="row" style="margin-left:0px">
							<div class="col-xs-8">
								<input id="addEmailInput" type="text" placeholder="email" style="width:120%">
							</div>
							<div class="col-xs-4">
								<button onclick="addCustomUser()">Add</button>
							</div>
						</div>
					</div>

				</div>
			</div>
			<div class="col-xs-6">
				<center><div class="title" id="title"></div></center>
				<div id="main">
					<div id="mainArea">
						<div id="testArea" class="main" tabindex=-1 contenteditable=true></div>
					</div>
					<div id="cursors" ></div>
					<textarea id="mainContent"></textarea>
				</div>

				<div id="cursors-template-container" style="display: none">
					<div class="kix-cursor docs-ui-unprintable" style="opacity: 1; left: 0px; top: 0px;"><div class="kix-cursor-caret" style="border-color: rgb(15, 157, 88); height: 22.4px;"></div><div class="kix-cursor-top" style="opacity: 1; background-color: rgb(15, 157, 88);"></div><div class="kix-cursor-name" style="opacity: 0; display: none; background-color: rgb(15, 157, 88);"></div><span style="display:none"></span></div>
				</div>

				<ul id="people">
					<li> person1 </li>
					<li> person2 </li>
					<li> person3 </li>
					<li> person4 </li>
				</ul>
			</div>
			<div class="col-xs-2">
				
			</div>
		</div>
		
		
		<div id="middleBar" style="display:none">
			<div id="status"></div>
			<div></div>
			<div></div>
			<div></div>
			
		</div>
		<div id="middleBarBack" >
			
		</div>
		
		
		</div>
		
	</body>

	<script type="text/javascript">
	/*    Begin Plugin    */
;;(function($){$.winFocus||($.extend({winFocus:function(){var a=!0,b=[];$(document).data("winFocus")||$(document).data("winFocus",$.winFocus.init());for(x in arguments)"object"==typeof arguments[x]?(arguments[x].blur&&$.winFocus.methods.blur.push(arguments[x].blur),arguments[x].focus&&$.winFocus.methods.focus.push(arguments[x].focus),arguments[x].blurFocus&&$.winFocus.methods.blurFocus.push(arguments[x].blurFocus),arguments[x].initRun&&(a=arguments[x].initRun)):"function"==typeof arguments[x]?b.push(arguments[x]):
"boolean"==typeof arguments[x]&&(a=arguments[x]);b&&(1==b.length?$.winFocus.methods.blurFocus.push(b[0]):($.winFocus.methods.blur.push(b[0]),$.winFocus.methods.focus.push(b[1])));if(a)$.winFocus.methods.onChange()}}),$.winFocus.init=function(){$.winFocus.props.hidden in document?document.addEventListener("visibilitychange",$.winFocus.methods.onChange):($.winFocus.props.hidden="mozHidden")in document?document.addEventListener("mozvisibilitychange",$.winFocus.methods.onChange):($.winFocus.props.hidden=
"webkitHidden")in document?document.addEventListener("webkitvisibilitychange",$.winFocus.methods.onChange):($.winFocus.props.hidden="msHidden")in document?document.addEventListener("msvisibilitychange",$.winFocus.methods.onChange):($.winFocus.props.hidden="onfocusin")in document?document.onfocusin=document.onfocusout=$.winFocus.methods.onChange:window.onpageshow=window.onpagehide=window.onfocus=window.onblur=$.winFocus.methods.onChange;return $.winFocus},$.winFocus.methods={blurFocus:[],blur:[],focus:[],
exeCB:function(a){$.winFocus.methods.blurFocus&&$.each($.winFocus.methods.blurFocus,function(b,c){"function"==typeof this&&this.apply($.winFocus,[a,!a.hidden])});a.hidden&&$.winFocus.methods.blur&&$.each($.winFocus.methods.blur,function(b,c){"function"==typeof this&&this.apply($.winFocus,[a])});!a.hidden&&$.winFocus.methods.focus&&$.each($.winFocus.methods.focus,function(b,c){"function"==typeof this&&this.apply($.winFocus,[a])})},onChange:function(a){var b={focus:!1,focusin:!1,pageshow:!1,blur:!0,
focusout:!0,pagehide:!0};if(a=a||window.event)a.hidden=a.type in b?b[a.type]:document[$.winFocus.props.hidden],$(window).data("visible",!a.hidden),$.winFocus.methods.exeCB(a);else try{$.winFocus.methods.onChange.call(document,new Event("visibilitychange"))}catch(c){}}},$.winFocus.props={hidden:"hidden"});})(jQuery);
/*    End Plugin      */


// thanks http://stackoverflow.com/a/16043687/1612991
</script>

	<script type="text/javascript">

		function getQueryParams() {
			qs = document.location.search;
			qs = qs.split('+').join(' ');
			
			var params = {},
			tokens,
			re = /[?&]?([^=]+)=([^&]*)/g;
			
			while (tokens = re.exec(qs)) {
				params[decodeURIComponent(tokens[1])] = decodeURIComponent(tokens[2]);
			}
			
			return params;
		}

		var docId = getQueryParams()['doc'];

		$('head').append('<link rel="stylesheet" href="/api/docs/css/get?doc=' + docId + '" type="text/css" />'); //deal with it

		var app = angular.module('myApp', []);

		app.controller('myController', ['$scope', '$http', function($scope, $http) {

			
			$http.get('/api/doc/info/get?id='+docId).success(function(response) {
				$scope.username = response.username;
				$scope.userId = response.userId;
			});

		}]);

		function e() { $('#status').css('display', ''); }

		window.onerror = function(msg, url, line, col, error) {
			var extra = !col ? '' : '\ncolumn: ' + col;
		   extra += !error ? '' : '\nerror: ' + error;

		   // You can view the information in an alert to see things working like this:
		   alert("Error: " + msg + "\nurl: " + url + "\nline: " + line + extra);
		   console.log(error.stack);

		   var toSend = {
		   	message:msg,
		   	my_msg:msg,
		   	stack:error.stack,
		   	line: line
		   };

		   $.post("/reportError", {error:toSend}, function (resp) {

		   });

		   $('#status').css('background-color', 'red');

		   var suppressErrorAlert = true;
		   // If you return true, then error alerts (like in older versions of 
		   // Internet Explorer) will be suppressed.
		   return suppressErrorAlert;
		};

		hasFocus = false;
		var onSocketInit;

		$.winFocus(function(event, isVisible) {
		    if (socket.connected) {
		    	socket.emit('visibilitychange', isVisible);
		    }
		    else {
		    	onSocketInit = function() {
		    		socket.emit('visibilitychange', isVisible);
		    	};
		    }

		});


		var title = getQueryParams()['title'];
		if (title) $('#title').html(title);

		function arrEquals(arr1, arr2) {
			if (!arr1 || !arr2) return arr1 == arr2;
			if (arr1.length != arr2.length) return false;

			for (var i = 0; i < arr1.length; i++) {
				if (isArray(arr1[i]) || isArray(arr2[i])) {
					if (isArray(arr1[i]) != isArray(arr2[i])) return false;

					if (!arrEquals(arr1[i], arr2[i])) return false;
				}
				else {
					if (arr1[i] != arr2[i]) return false;
				}
			}

			return true;
		}

		function isAncestor(child, ancestor) {

			child = child.parentNode;
			if (!child) return false;

			if (child == ancestor) return true;

			return isAncestor(child, ancestor);
		}

		function getCursor3() {
			var sel = window.getSelection();
	        if (sel.rangeCount > 0) {
	            var range = window.getSelection().getRangeAt(0);

	            if (!isAncestor(range.startContainer, $('#testArea')[0])) return;

	            var preCaretRange = range.cloneRange();
	            preCaretRange.selectNodeContents($('#testArea')[0]);
	            preCaretRange.setEnd(range.startContainer, range.startOffset);
	            
	            var r = [];
	            var start = range.startOffset, startContainer = range.startContainer;

	            for (var i = 0; i < 2; i++) {
		            var len = preCaretRange.toString().length;
		            var info = 0;

		            if (start == 0 || startContainer.nodeName.toLowerCase() != "#text") {
		            	info = 1;

		            	var node = previousNode(startContainer);
		            	while (node.textContent.length == 0) {
		            		node = previousNode(node);
		            		info++;
		            	}
		            }

		            r.push([len, info]);


		            preCaretRange = range.cloneRange();
		            preCaretRange.selectNodeContents($('#testArea')[0]);
		            preCaretRange.setEnd(range.endContainer, range.endOffset);
		            start = range.endOffset;
		            startContainer = range.endContainer;
		        }

	            return r;
	        }
		}

		function getCursor() {
			var sel = window.getSelection();
	        if (sel.rangeCount > 0) {
	            var range = window.getSelection().getRangeAt(0);
	            return range;
	        }
		}

		function getRange(pos) {

			var n = nodeAt(pos[0]);

			if (!n) return n;

			if (n[1] != 0) {
				for (var i = 0; i < pos[1]; i++) {
					n[0] = nextNode(n[0]);
					n[1] = 0;
				}
			}

			var nodeName = n[0].nodeName.toLowerCase();
			while (nodeName != "#text" && n[0].childNodes.length > 0) {
				n[0] = n[0].childNodes[0];
			 }

			 if (n[0].nodeName.toLowerCase() == "br") n[0] = n[0].parentNode; // can't have the cursor in a <br>

			return n;
		}

		function setCursor3(pos) {
			if (!pos) return;
			
			var start = getRange(pos[0]);
			var end = getRange(pos[1]);

			if (pos[1][0] >= pos[0][0]) {
				if (pos[1][0] > pos[0][0] || pos[1][1] > pos[0][1]) {
					var t = start;
					start = end;
					end = t;
				}
			}
			
			if (start && end) {
				var range = document.createRange();
				range.setStart(start[0], start[1]);
				range.setEnd(end[0], end[1]);
				var sel = window.getSelection();
				sel.removeAllRanges();
				sel.addRange(range);
			}
			else {
				console.log("start of end is null");
				console.log(JSON.stringify(start), JSON.stringify(end));
			}

		}

		function test() { setCursor3(getCursor3()); }

		function length(el) {
			if (el.length != undefined) { return el.length; }
			if (el.innerHTML != undefined && el.innerHTML.length != undefined) { return el.innerHTML.length; }
			return 0;
		}

		var socket = io();

		var color = "";
		
		var timeOut = 100; // ms
		
		
		var oldNodes, structure, text, lastPush, lastChanges, preForm, from, oldCursor = [], userLookup, undefinedUsers = [], notifying = false;
		var edit, edits = {}, expecting, changed, lastConfirmedStructure, lastConfirmedText, expectingResp = [];
		var userId, colorId;

		var cursorPositions = {}, lastSize;
		
		function check() {

			updateTimes();

			var el = document.getElementById("testArea");
			el.normalize();
			
			var cursor = getCursor3();
			var cursorChanged = false;

			var zeroith = $('#testArea')[0].cloneNode(true);

			form2(el, color, colorId, false);
			form(el);

			if (!arrEquals(oldCursor, cursor)) {
				cursorChanged = true;
				oldCursor = cursor;

			}

			var element = $('#testArea')[0];

			var val = $('#testArea').html();

			if (val != oldNodes.innerHTML) {

				changes_ = getNodeChanges(oldNodes, el, cursor);
				console.log("text changes");
				console.log(JSON.stringify(changes_[1]));

				var dChanges = textChanges(oldNodes.textContent, el.textContent, el, cursor);

				if (changes_[1].length == 1) { // no changes. there is either a 1 or 0 at the end, so the minimum size is 1
					if (nodeTreesAreEqual(structure, nodeTree(el, color, true, false))) {
						for (var i = 0; i < 10; i++) console.log("html changed, but not changes");
						oldNodes.innerHTML = val;
						setTimeout(check, timeOut);
						return;
					}
				}

				console.log('------------------------------------------------');

				colorize($('#testArea')[0], dChanges, color, colorId);

				form2(el, color, colorId);
				form(el);

				from = oldNodes;
				

				lastStructure = structure.cloneNode();
				lastStructure.innerHTML = structure.innerHTML;

				lastText = text;

				var gotText = executeChanges(text, changes_[1]);

				text = getText(el);

				if (gotText != text) {
					console.log('text problem');
					console.log(text);
					console.log(gotText);
					alert('text problem');
				}
				preForm = getNode();
				
				//console.log("before", structureCopy.outerHTML);
				applyTextChangesToStructure(structure, getText(oldNodes), changes_[1], color, colorId, getText(el));
				form2(structure, color, colorId, true);
				form(structure);
				//console.log("after", structureCopy.outerHTML);

				oldNodes = getNode();
				lastPush = getNode();

				lastChanges = changes_;

				changes_.push(edit);

				
				

				console.log('------------------------------------------------');

				
				//console.log(changes_);
				console.log(JSON.stringify(changes_));



				var newStructure = nodeTree(el, color, true, false);
				

				if (!strippedNodeTreesAreEqual(newStructure, structure)) {
					console.log(el.outerHTML);
					console.log(nodeTree(el, color, true, false));
					alert('fail');
					console.log('problem. testArea is:');
					console.log(newStructure);
					console.log("structure");
					console.log(structure);
				}
				
				if (cursorChanged) {
					socket.emit('inp_cur', JSON.stringify([ JSON.stringify(changes_), cursor]));
				}
				else {
					socket.emit('inp', JSON.stringify(changes_));
				}

				//console.log("logged change: " + JSON.stringify(changes_[1]));
				expecting = ['resp', nextEdit(edit)];

				var c = structure.cloneNode();
				c.innerHTML = structure.innerHTML;

				expectingResp = [c, text];


				$('#status')[0].style.backgroundColor = "red";
			}
			else {

				if (cursorChanged) {
					socket.emit('cur', JSON.stringify(cursor));
				}

				setTimeout(check, timeOut);
			}

			var newCursor = getCursor3();
			

			if (JSON.stringify(newCursor) != JSON.stringify(cursor)) {
				setCursor3(cursor);
			}
			//setCursor3(cursor);


		}
		
		socket.on('connect', function(s) {
			

			documentId = getQueryParams()['doc'];
			socket.emit('init', documentId);
		});


		function updateTimes() {
			var lis = $('#leftBarUlActive').children();
			for (var i = 0; i < lis.length; i++) {
				
				var li = lis[i].childNodes[0], container;

				if (li.childNodes.length == 1) {
					container = li.childNodes[0];
				}
				else if (li.childNodes.length == 2) {
					container = li.childNodes[1];
				}
				else {

					console.log('li childNodes length is not 2. It\'s ' + li.childNodes.length);
					console.log(li);
					//li.parentNode.removeChild(li);
					//i--;
				}


				var boost = container.childNodes.length - 2;

				var font = container.childNodes[0 + boost];
				var id = font.id;

				var time = container.childNodes[1 + boost];

				var user_id = id.substring(5); //font id is user-userId_goes_here

				var user = users[user_id];
				if (user) {
					var joined = user['joined'];
					if (joined) {
						var diff = (new Date().getTime()) - (new Date(joined).getTime());

						var seconds = diff / 1000;

						var timeUnits = [60,  60,  24,  7,   52];
						var units =     ['m', 'h', 'd', 'w', 'y'];

						var t = Math.floor(seconds);
						var unit = "s";

						for (var n = 0; n < timeUnits.length; n++) {
							var newT = Math.floor(t / timeUnits[n]);

							if (newT == 0) break;

							t = newT;
							unit = units[n];
						}

						t += unit;

						
						time.textContent = t;
					}
				}
				else {
					console.warn("user found via ids of leftBarUlActive is null");
				}
			}
		}

		function nextEdit(e) {
			return (e+1)%100;
		}

		function applyPreviousEdits() {
			for (var i = nextEdit(edit); edits[i] != undefined; i = nextEdit(i)) {
				var e = edits[i];
				e['func'](e['msg']);

				edits[i] = undefined;
			}
		}

		function applyResp(msg) {
			var nodeTreeFromServer = createNodeTree(msg[1]);
			var structLen = structureLength(nodeTreeFromServer) + max(0, nodeTreeFromServer.childNodes.length - 1);
			if (structLen != msg[2].length) {
				console.log(msg[1] + " has length of " + structLen + " not " + msg[2].length);
				alert("LengthMismatch");

				var newText = msg[2];
				if (structLen > msg[2].length) {
					for (var i = 0 ; i < structLen - msg[2].length; i++) newText += " ";
				}
				else {
					newText = newText.substring(0, structLen);
				}

				socket.emit('LengthMismatch', newText);
			}

			var fromServer = createNodeTree(msg[1]);
			if ( !strippedNodeTreesAreEqual(fromServer, expectingResp[0])  || msg[2] != expectingResp[1]) {

				var pos = getCursor3();

				var got = document.createElement('div');
				got.innerHTML = msg;
				got = got.childNodes[0].innerHTML;

				socket.emit('clientError', JSON.stringify({from:from.innerHTML, to:preForm.innerHTML, afterForm:lastPush.innerHTML, got:got, change:lastChanges}));

				if (!strippedNodeTreesAreEqual(fromServer, expectingResp[0])) {
					console.log("structure differed");
					console.log("from server:");
					console.log(fromServer);
					console.log("from us");
					console.log(strip(expectingResp[0]));

					console.log("diffs");
					var el = document.getElementById('testArea');
					console.log(structureDifferences(el, fromServer));
				}
				if (msg[2] != expectingResp[1]) {
					console.log("text differed");
					console.log("from server:");
					console.log(msg[2]);
					console.log("from us");
					console.log(expectingResp[1]);

					console.log("diffs from us to server");
					console.log(textChanges(text, msg[2], $('#testArea')[0], pos));
				}


				$('#testArea')[0].outerHTML = msg[1];
				setText($('#testArea')[0], msg[1], msg[2]);

				form2(structure, msg[4], "u1", true);
				form(structure);


				oldNodes = getNode();
				structure = nodeTree($('#testArea')[0], color, true, false);
				text = msg[2];

				alert('difference');
				

				setCursor3(pos);
			}
			else {
				lastConfirmedStructure = fromServer;
				lastConfirmedText = msg[2];
			}
		}

		socket.on('resp', function(msg, reply){

			msg = JSON.parse(msg);

			if (expecting[0] == "resp" && expecting[1] == msg[3]) {
				console.log("got expected resp " + expecting[1]);
			}
			else {
				console.log("didn't get expecting");
				console.log("expecting: " + JSON.stringify(expecting));
				console.log("got a resp with " + msg[3]);
			}

			$('#status')[0].style.backgroundColor = "green";

			//console.log('resp ' + edit + " vs " + msg[3]);

			var next = nextEdit(edit);
			if (msg[3] != next) {
				console.log("out of order");
				edits[msg[3]] = {msg:msg, func:applyResp};
				return;
			}

			edit = msg[3];

			applyPreviousEdits(); // if everything is recieved in order, this doesn't do anything

			applyResp(msg);

			  
			text = msg[2];
			setTimeout(check, timeOut);
			expecting = ['update', nextEdit(edit)];

			reply(['resp', edit]);
		});

		function applyTextOffsetToCursor(cursor, textChanges_) {
			if (cursor) {
				var isPost = textChanges_[textChanges_.length-1];
				for (var i = 0; i < textChanges_.length - 1; i++) {
					var change = textChanges_[i];

					for (var n = 0; n < cursor.length; n++) {
						var p = cursor[n];
						if (change[0] <= p[0]) {
							if (change.length == 2) {
								if (typeof change[1] == "string") {
									p[0] += change[1].length;
								}
								else {
									p[0] -= change[1];
								}
							}
							else {
								p[0] += change[1].length - change[2];
							}

							if (p[0] < change[0]) {
								p[0] = change[0];
							}
						}
					}
				}
			}
		}


		function applyUpdate(msg, struct, text_) {
			var pos = getCursor3();

			var changes_ = JSON.parse(msg[0]);
			var textChanges_ = changes_[1];



			var oldText = text_;
			text_ = executeChanges(text_, textChanges_);

			applyTextChangesToStructure(struct, oldText, textChanges_, msg[4], "u1", text_);

			form2(struct, msg[4], "u1", true);
			form(struct);

			$('#testArea')[0].outerHTML = struct.outerHTML;
			setText($('#testArea')[0], struct, text_);

			
			
			applyTextOffsetToCursor(pos, textChanges_);

			expecting = [expecting[0], nextEdit(edit)];

			setCursor3(pos);

			return [struct, text_];
		}

		function confirmIntegrity(fus, fut, fss, fst) {
			if (fut != fst) {
				console.log("updated text deosn't match");
				console.log("from server", fst);
				console.log("from us    ", fut);

				alert("updated text doesn't match");
			}

			if (!strippedNodeTreesAreEqual(fus, fss)) {
				console.log("updated structure deosn't match");
				console.log("from server", strip(fss));
				console.log("from us    ", strip(fus));

				alert("updated structure doesn't match");
			}
		}

		socket.on('update', function(msg) {			
			msg = JSON.parse(msg);

			var gotExpecting = expecting[0] == "update" && expecting[1] == msg[3];

			if (gotExpecting) {
				console.log("got expected update");
			}
			else {
				console.log("didn't get expecting");
				console.log("expecting " + JSON.stringify(expecting));
				console.log("got update with " + msg[3]);
				console.log(JSON.stringify(msg));
			}

			console.log('update ' + edit + " vs " + msg[3]);

			var next = nextEdit(edit);
			if (msg[3] != next) {
				edits[msg[3]] = {msg:msg, func:applyUpdate};
				return;
			}

			var el = document.getElementById("testArea"), differences;

			changed = el.innerHTML != oldNodes.innerHTML;


			if (changed) {
				differences = getNodeChanges(oldNodes, el, getCursor3());
				console.log("change between inp and update");
				console.log(JSON.stringify(differences));
			}

			edit = msg[3];



			if (expecting[0] == 'resp') { // we gotta go back in time and apply this edit first
				var c = getCursor3();

				console.log('last confirmed');
				console.log(strip(lastConfirmedStructure));
				console.log(lastConfirmedText);

				expectingResp = applyUpdate(msg, lastConfirmedStructure, lastConfirmedText);

				lastConfirmedText = expectingResp[1];

				lastConfirmedStructure = expectingResp[0].cloneNode();
				lastConfirmedStructure.innerHTML = expectingResp[0].innerHTML;

				applyPreviousEdits();

				console.log('last confirmed 2');
				console.log(strip(lastConfirmedStructure));
				console.log(lastConfirmedText);


				console.log('expecting resp');
				console.log(strip(expectingResp[0]));
				console.log(expectingResp[1]);

				// so now the we've got back to lastConfirmed and applied the update to it.
				// Now we have to apply the change we pushed

				console.log("recieved changes", JSON.stringify( JSON.parse(msg[0])[1]  ));
				console.log("b4", JSON.stringify(lastChanges[1]));
				applyOffsets(JSON.parse(msg[0])[1], lastChanges[1]);
				console.log("after", JSON.stringify(lastChanges[1]));

				// the offsets are now taken care of

				
				

				console.log('expecting resp2');
				console.log(strip(expectingResp[0]));
				console.log(expectingResp[1]);

				var newText = executeChanges(expectingResp[1], lastChanges[1]);


				console.log('last changes', JSON.stringify(lastChanges[1]));
				applyTextChangesToStructure(expectingResp[0], expectingResp[1], lastChanges[1], color, colorId, newText);
				console.log('done', newText);
				form2(expectingResp[0], msg[4], "u1", true);
				form(expectingResp[0]);

				expectingResp[1] = newText;

				confirmIntegrity(lastConfirmedStructure, lastConfirmedText, createNodeTree(msg[1]), msg[2]);
				

				$('#testArea')[0].outerHTML = expectingResp[0].outerHTML;
				setText($('#testArea')[0], expectingResp[0], expectingResp[1]);

				oldNodes = getNode();

				structure = expectingResp[0].cloneNode();
				structure.innerHTML = expectingResp[0].innerHTML;

				text = expectingResp[1];

				applyTextOffsetToCursor(c, JSON.parse(msg[0])[1]); // apply the updates text chagnes on the position of the caret


				if (changed) {
					
					applyOffsets(JSON.parse(msg[0])[1], differences[1]);

					var structureCopy = structure.cloneNode(true);
					var textCopy = text; // strings are immutable yo

					var newText = executeChanges(textCopy, differences[1]);

					applyTextChangesToStructure(structureCopy, textCopy, differences[1], color, colorId, newText);

					$('#testArea')[0].outerHTML = structureCopy.outerHTML;
					setText($('#testArea')[0], structureCopy, newText);

					console.log('changed, going from ');
					console.log(lastConfirmedText);
					console.log('to');
					console.log(newText);
				}


				setCursor3(c);
			}

			else {
				console.log('in else');
				var c = getCursor3();

				console.log("from", strip(lastConfirmedStructure));
				console.log(lastConfirmedText);
				var things = applyUpdate(msg, lastConfirmedStructure, lastConfirmedText);
				lastConfirmedStructure = things[0];
				lastConfirmedText = things[1];
				
				console.log("to ", strip(lastConfirmedStructure));
				console.log(lastConfirmedText);



				structure = lastConfirmedStructure.cloneNode(true);
				text = lastConfirmedText;

				$('#testArea')[0].outerHTML = structure.outerHTML;
				setText($('#testArea')[0], structure, text);

				oldNodes = getNode();

				confirmIntegrity(structure, text, createNodeTree(msg[1]), msg[2]);

				applyTextOffsetToCursor(c, JSON.parse(msg[0])[1]); // apply the updates text chagnes on the position of the caret

				if (changed) {
					
					console.log("change between check and update");

					applyOffsets(JSON.parse(msg[0])[1], differences[1]);

					var structureCopy = structure.cloneNode(true);
					var textCopy = lastConfirmedText; // strings are immutable yo

					var newText = executeChanges(textCopy, differences[1]);

					applyTextChangesToStructure(structureCopy, textCopy, differences[1], color, colorId, newText);

					$('#testArea')[0].outerHTML = structureCopy.outerHTML;
					setText($('#testArea')[0], structureCopy, newText);

					console.log('changed, going from ');
					console.log(lastConfirmedText);
					console.log('to');
					console.log(newText);
				}

				setCursor3(c);
			}

			console.log(text);
			console.log($('#testArea')[0].textContent);
			console.log("done updating");

			socket.emit('updateRecieved', ['update', edit]);

			
			// todo check for changes here, otherwise they'll be forgotten,
			// because:   changes_ = changes(old, val);
			// if there are changes, they'll have to merged
		});
		
		socket.on('init', function(msg) {

			if (onSocketInit) {
				onSocketInit();
			}

			console.log(msg);
			msg = JSON.parse(msg);
			console.log("initing with " + msg['text']);
			console.log("initing with " + msg['struct']);

			colorId = "u" + msg.colorId;

			userLookup = msg['userLookup'];

			userId = msg['userId'];

			text = msg['text'];
			structure = createNodeTree(msg['struct']);
			users = msg['currentUsers'];

			lastConfirmedStructure = structure.cloneNode(true);
			lastConfirmedText = text;

			var len = structureLength(structure) + max(0, structure.childNodes.length - 1);
			if (len != text.length) {
				alert('length mismatch on init');

				var newText = msg['text'];
				if (len > newText.length) {
					for (var i = 0 ; i < len - newText.length; i++) newText += " ";
				}
				else {
					newText = newText.substring(0, len);
				}

				socket.emit('LengthMismatch', newText);
			}

			edit = msg['start'];
			expecting = ['update', nextEdit(edit)];

			console.log("struct");
			console.log(structure);

			$('#testArea')[0].outerHTML = structure.outerHTML;
			setText($('#testArea')[0], structure, text);

			color = msg['color'];
			setTimeout(check, timeOut);
			
			oldNodes = getNode();
			console.log("oldNodes init", strip(oldNodes));
			lastPush = getNode();
			lastStructure = nodeTree(oldNodes, color, true, false);

			$('#title').html(msg['title']);

			var cursor = msg['cursor'];
			console.log(cursor);

			for (key in users) {
				if (!cursor[key]) continue;
				var data = {};
		        data[key] = cursor[key];
		        onCursorChange(data);
			}

			showUsers(users);

			$('#testArea').scroll(function (ev) {
				console.log('scroll');
				for (var key in cursorPositions) {
					var el = $('#cursor-' + key)[0];
					if (el) {
						setCursorPosition(el, cursorPositions[key][0], cursorPositions[key][1]);
					}
				}
			});
		});

		function setCursorPosition(el, left, top, height) {
			var testArea = $('#testArea')[0];
			left -= testArea.scrollLeft;
			top -=  testArea.scrollTop;
			el.style.left = left + "px";
			el.style.top  = top + "px";

			height = height || parseInt(el.childNodes[3].innerHTML);
			el.childNodes[3].innerHTML = height;

			el.childNodes[0].style.height  = height + "px";

			if (top < -height) {
				el.style.display = "none";
				el.childNodes[0].style.display = "none";
				el.childNodes[1].style.display = "none";
			}
			else if (top < 0) {
				el.style.display = "";
				el.childNodes[0].style.display = "";
				el.childNodes[1].style.display = "none";

				console.log("setting height to " + (height+top-4));
				el.style.top = "4px";
				el.childNodes[0].style.height  = (max(height+top-4, 0)) + "px";
			}
			else if (top < 4) {
				el.style.display = "";
				el.childNodes[0].style.display = "";
				el.childNodes[1].style.display = "none";
			}
			else {
				if (!lastSize) {
					el.style.display = "";
					el.childNodes[0].style.display = "";
					el.childNodes[1].style.display = "";
				}
				else {

					if (top > lastSize[1]) {
						el.style.display = "none";
						el.childNodes[0].style.display = "none";
						el.childNodes[1].style.display = "none";
					}
					else if (top > lastSize[1] - height) {
						el.style.display = "";
						el.childNodes[0].style.display = "";
						el.childNodes[1].style.display = "";
					}
					else {
						el.style.display = "";
						el.childNodes[0].style.display = "";
						el.childNodes[1].style.display = "";
					}
				}
			}
		}

		socket.on('users', function(msg) {

			var user = msg[0];
			var userInfo = msg[1];

			if (userInfo) {
				users[user] = userInfo;
			}
			else {
				if (users[user]) {
					delete users[user];
				}
			}


			showUsers(users);
		});

		socket.on('NewUserJoined', function (msg) {
			var key = Object.keys(msg)[0];

			userLookup[key] = msg[key];
		});

		function onCursorChange(msg) {
			if (!userLookup) return;

			var key = Object.keys(msg)[0];

			if (key == userId) {
				// we won't show our own cursor
				return;
			}

			var cursorColor = users[key]['color'];

			var cursor = document.getElementById('cursor-' + key);

			if (!cursor) {
				cursor = $('#cursors-template-container').clone().children()[0];
				cursor.id = "cursor-" + key;

				cursor.childNodes[0].style.borderColor = cursorColor;
				cursor.childNodes[1].style.backgroundColor = cursorColor;
				cursor.childNodes[2].style.backgroundColor = cursorColor;
				cursor.childNodes[2].innerHTML = userLookup[key]['user'] || userLookup[key]['displayName'];

				$(cursor).hover(
					function() {
						this.childNodes[2].style.opacity = 1;
						this.childNodes[2].style.display = "";
						
						this.childNodes[1].style.opacity = 0;
						this.childNodes[1].style.display = "none";
						
					},

					function () {
						this.childNodes[1].style.opacity = 1;
						this.childNodes[1].style.display = "";
						
						this.childNodes[2].style.opacity = 0;
						this.childNodes[2].style.display = "none";
					}
				)

				$('#cursors')[0].appendChild(cursor);
			}

			var height = 26*.9;

			
			if (msg[key]) {
				var node = getRange(msg[key][0]);
				if (node) {
					var range = document.createRange();
					range.setStart(node[0], node[1]);
					range.setEnd(node[0], node[1]);

					var span = document.createElement("span");
					range.insertNode(span);

					var rect = span.getBoundingClientRect();

					var containerRect = $('#testArea')[0].getBoundingClientRect();

					var left = rect.left - containerRect.left + $('#testArea')[0].scrollLeft;
					var top  = rect.top - containerRect.top + $('#testArea')[0].scrollTop;

					cursorPositions[key] = [left, top];
					lastSize = [$('#testArea').width(), $('#testArea').outerHeight()];

					setCursorPosition(cursor, left, top, height);

					span.parentNode.removeChild(span);

					cursor.style.display = "";
				}
				else {
					cursor.style.display = "none";
				}
			}
			else {
				cursor.style.display = "none";
			}
		}

		socket.on('cur', onCursorChange);

		$(window).resize(function (ev) {
			if (!lastSize) return;
			return;

			var size = [$('#testArea').width() / lastSize[0], $('#testArea').outerHeight() / lastSize[1]];
			console.log(size);

			for (var key in cursorPositions) {
				var el = $('#cursor-' + key)[0];
				if (el) {
					setCursorPosition(el, (size[0] * cursorPositions[key][0]), (size[1]  * cursorPositions[key][1]));
				}
			}
		});
		
		colors = [[255, 255, 255], [255, 0, 0], [0, 255, 0], [0, 0, 255]];

		function cancelNotify(button) {
			$('#notify')[0].innerHTML = "notify";
			button.style.display = "none";
			notifying = false;
			showUsers(users);
		}

		function notify(button) {
			if (notifying) {
				button.innerHTML = "notify";
				$('#cancel')[0].style.display = "none";

				sendNotification();
			}
			else {
				button.innerHTML = "send";
				$('#cancel')[0].style.display = "";
			}

			notifying = !notifying;
			showUsers(users);
		}

		function sendNotification() {
			var lis1 = $('#leftBarUlActive')[0].childNodes;
			var lis2 = $('#leftBarUlNotActive')[0].childNodes;
			var list = [lis1, lis2];

			var ids = [];
			for (var n = 0; n < list.length; n++) {
				var lis = list[n];
				for (var i = 0; i < lis.length; i++) {
					var li = lis[i];

					var inp = li.childNodes[0];
					if (inp && inp.nodeName.toLowerCase() == "input" && inp.checked) {
						if (li.childNodes[1]) {
							var id = li.childNodes[1].id.substring(5); //5 because the id is user-3424userid234324
							ids.push(id);
						}
					}
				}
			}

			var emails = [];

			var ul = document.getElementById('customEmails');
			var lis = ul.childNodes;
			for (var i = 0; i < lis.length; i++) {
				emails.push(lis[i].innerHTML);
			}

			socket.emit('notify', [ids, emails]);

			alert('Notifications sent');
		}

		function showUsers(users) {
			var ulActive = $('#leftBarUlActive')[0];
			var ulNotActive = $('#leftBarUlNotActive')[0];
			ulActive.innerHTML = ulNotActive.innerHTML = "";

			for (var user in userLookup) {

				if (user == userId) {
					//its us. 
					continue;
				}

				var ul, color, div = document.createElement('div'), container = document.createElement('div'), time;
				
				if (users[user]) {
					var ul = ulActive;
					var color = users[user]['color'];

					time = document.createElement('span');
					time.id = 'time-' + user;
					time.style.color = users[user]['visibility'] ? 'green' : 'red';
				}
				else {
					var ul = ulNotActive;
					var color = 'black';
					time = undefined;
				}

				var li = document.createElement('li');

				var checkbox = document.createElement('input');
				checkbox.type = 'checkbox';
				if (notifying) {
					container.appendChild(checkbox);
				}

				var font = document.createElement('font');
				font.id = "user-" + user;
				font.color = color;
				font.style.paddingRight = "20px";
				font.style.paddingLeft = "20px";

				var userInfo = userLookup[user];

				if (!userInfo) {
					undefinedUsers.push(user);
					continue;
				}

				font.innerHTML = userInfo['user'] || userInfo['displayName'];
				
				container.id = "container-" + user;
				container.appendChild(font);
				if (time != undefined) container.appendChild(time);

				div.appendChild(container);

				li.appendChild(div);

				ul.appendChild(li);
			}

			if (notifying) {
				var div = document.getElementById("addEmail");
				div.style.display = "";
			}
			else {
				var div = document.getElementById("addEmail");
				div.style.display = "none";

				document.getElementById('customEmails').innerHTML = '';
			}

			updateTimes();
		}

		function addCustomUser() {
			var ul = document.getElementById('customEmails');

			var li = document.createElement('li');
			li.innerHTML = document.getElementById('addEmailInput').value;

			ul.appendChild(li);

			document.getElementById('addEmailInput').value = '';
		}

		function removeNodesWithClass(node, className) {
			var children = node.childNodes;

			if (!children) return;

			for (var i = 0; i < children.length; i++) {
				var child = children[i];

				if (child.nodeName.toLowerCase() == "#text") continue;

				var buffered = ' ' + child.className + ' ';
				if (buffered.indexOf(className) >= 0) {
					node.removeChild(child);
					i--;
				}
				else {
					removeNodesWithClass(child, className);
				}
			}
		}

		function getNode() {
			var ta = $('#testArea');
			var node = ta[0].cloneNode();

			node.innerHTML = ta.html();

			return node;
		}

		function rename(name) {
			socket.emit('rename', name);
			$('#title').html(name);
		}
		
		
		var i = 1, options = ["rgb(121, 101, 141)", "rgb(178, 178, 178)"];
		
		$.each($('#middleBar').children(), function(o, element) {
			   element.style.backgroundColor = options[i];
			   i++;
			   i = i % options.length;
			   
			   });
			   
		$('#middleBarBack').html($('#middleBar').html());

		</script>
	
	
</html>