<!doctype html>
<html>
	<head>
		<title>Connectivity</title>
		<script type="text/javascript" src="/socket.io-1.2.0.js"></script>
		<script type="text/javascript" src="/jquery-1.11.1.js"></script>
		<script type="text/javascript" src="/bootstrap/js/bootstrap.min.js"></script>
		<script type="text/javascript" src="/diff.js"></script>
		<script type="text/javascript" src="/change.js"></script>
		<script type="text/javascript" src="/tinycolor.js"></script>
		
		<link href="/bootstrap/css/bootstrap.min.css" rel="stylesheet">
	</head>
	


<style>
		body {
			background: rgb(15,4,87);
		}
	
	.title {
		font-size: 24px;
		font-family:"Courier";
		font-weight: bold;
		padding-bottom: none;
		color:white;
	}

	#leftBar {
		width:50%;
		margin-left:25%;
		margin-top: 25vh;
		height: 60vh;
		background-color: rgb(255, 255, 255);
		border-radius: 15px;
		border:3px dotted rgb(51, 133, 51);
		font-family: "Courier";
		font-size: 15px;
		font-weight: bold;
		text-align: center;
	}

	#leftBar > ul {
		list-style-type: none;
		margin-top: 20px;
		padding-left:0;
	}
	
	#main {
		height: 85vh;
		
	}
	#mainContent {
		position: fixed;
		top: 0;
		left: 0;
		padding: 0;
		height: 100px;
		width: 0px;
		overflow-y: hidden;
		outline: none;
		font-size: 24px;
		background-color: #fff;
		nothing: rgb(255, 246, 211);
		border-radius: 0px;
		border: none;
		resize: none;
	}

	#testArea {
		background-color:rgb(255, 255, 255);
		height: 100vh;
		z-index: -1;
		font-size: 18px;
		font-family: "Courier";
		padding-left: 20px;
		padding-top: 15px;
		border: 4px solid rgb(51, 133, 51);
		border-radius:20px;
		margin-top:2vh;
		overflow: scroll;
	}
	
	
	
	#people li{
		display: inline;
	}
	
	.row {
		width:100%;
	}
	
	#rightBar {
		position: fixed;
		top: 30vh;
		right: 0;
		height: 30vh;
		width: 20%;
		background-color: rgb(245, 193, 124);
	}
	
	
	#middleBar {
		position: fixed;
		top: 30vh;
		right: 0;
		height: 30vh;
		width: 25%;
		background-color: rgb(150, 108, 67);
	}
	
	#middleBar *,  #middleBarBack *{
		position: relative;
		top: .3vh;
		padding-right: 15px;
		font-size: 18px;
		font-family: Tahoma;
		color: rgb(255, 204, 153);
		height: 25%;
		text-align: right;	
		border: none;
	}
	
	#middleBarBack {
		position: fixed;
		top: 35vh;
		right: 0;
		height: 30vh;
		width: 100%;
		z-index: -1;
	}
	
	#status{
		text-align: right;
		padding-right: 4em;
		padding-top: 15px;
		font-size: 18px;
		font-family: Tahoma;
		color: rgb(25, 89, 25);
	}

	.kix-cursor {
	  cursor: text;
	  position: absolute;
	  z-index: 24;
	}
	

	.kix-cursor-caret {
	  position: absolute;
	  width: 0px;
	  border-left: 2px solid;
	  font-size: 0;
	}

	.kix-cursor-top {
	  position: absolute;
	  width: 6px;
	  left: -2px;
	  top: -2px;
	  height: 6px;
	  font-size: 0;
	}
	

	.kix-cursor-name {
	  position: absolute;
	  font-size: 10px;
	  color: #fff;
	  top: -14px;
	  left: -2px;
	  padding: 2px;
	  white-space: nowrap;
	}

	#main {
		position: relative;
	}

	.wrapword{
		white-space: -moz-pre-wrap !important;  /* Mozilla, since 1999 */
		white-space: -pre-wrap;      /* Opera 4-6 */
		white-space: -o-pre-wrap;    /* Opera 7 */
		white-space: pre-wrap;       /* css-3 */
		word-wrap: break-word;       /* Internet Explorer 5.5+ */
		white-space: -webkit-pre-wrap; /* Newer versions of Chrome/Safari*/
		word-break: break-all;
		white-space: normal;

		}
	
	
	
		</style>

	
	<body>

		<nav class="navbar navbar-inverse navbar-static-top">
			<div class="container-fluid">
				<!-- Brand and toggle get grouped for better mobile display -->
				<div class="navbar-header">
					<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
						<span class="sr-only">Toggle navigation</span>
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
					</button>
					<ul class="nav navbar-nav">
						<li class="navbar-brand">
							<a style="top:-15px" href="/">HOME PAGE</a>
						</li>
					</ul>
				</div>
				
				<!-- Collect the nav links, forms, and other content for toggling -->
				<div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
					
					<ul class="nav navbar-nav navbar-right" style="margin-right: 5%">
						<li><a href="javascript:alert('not live yet');">{{ username }}</a></li>
						<li><a href="/logout">Sign out</a></li>
					</ul>
					
				</div><!-- /.navbar-collapse -->
			</div><!-- /.container-fluid -->
		</nav>

		<div id="status" style="position: fixed; width: 50px; height: 50px; right: 0px; top 50px; background-color:green; display:none"></div>
		
		<div class="row">
			<div class="col-xs-4">
				<div id="leftBar">
					<center>
						<button id="notify" onclick="notify(this)">notify</button>
						<button id="cancel" onclick="cancelNotify(this)" style="display:none">cancel</button>
					</center>
					<ul id="leftBarUlActive"></ul>
					<hr/>
					<ul id="leftBarUlNotActive"></ul>
				</div>
			</div>
			<div class="col-xs-6">
				<center><div class="title" id="title"></div></center>
				<div id="main">
					<div id="mainArea">
						<div id="testArea" class="main" tabindex=-1 contenteditable=true></div>
					</div>
					<div id="cursors" ></div>
					<textarea id="mainContent"></textarea>
				</div>

				<div id="cursors-template-container" style="display: none">
					<div class="kix-cursor docs-ui-unprintable" style="opacity: 1; left: 0px; top: 0px;"><div class="kix-cursor-caret" style="border-color: rgb(15, 157, 88); height: 22.4px;"></div><div class="kix-cursor-top" style="opacity: 1; background-color: rgb(15, 157, 88);"></div><div class="kix-cursor-name" style="opacity: 0; display: none; background-color: rgb(15, 157, 88);"></div><span style="display:none"></span></div>
				</div>

				<ul id="people">
					<li> person1 </li>
					<li> person2 </li>
					<li> person3 </li>
					<li> person4 </li>
				</ul>
			</div>
			<div class="col-xs-2">
				
			</div>
		</div>
		
		
		<div id="middleBar" style="display:none">
			<div id="status"></div>
			<div></div>
			<div></div>
			<div></div>
			
		</div>
		<div id="middleBarBack" >
			
		</div>
		
		
		
		
	</body>

	<script type="text/javascript">

		function e() { $('#status').css('display', ''); }

		window.onerror = function(msg, url, line, col, error) {
			var extra = !col ? '' : '\ncolumn: ' + col;
		   extra += !error ? '' : '\nerror: ' + error;

		   // You can view the information in an alert to see things working like this:
		   alert("Error: " + msg + "\nurl: " + url + "\nline: " + line + extra);
		   console.log(error.stack);

		   var toSend = {
		   	message:msg,
		   	my_msg:msg,
		   	stack:error.stack,
		   	line: line
		   };

		   $.post("/reportError", {error:toSend}, function (resp) {

		   });

		   $('#status').css('background-color', 'red');

		   var suppressErrorAlert = true;
		   // If you return true, then error alerts (like in older versions of 
		   // Internet Explorer) will be suppressed.
		   return suppressErrorAlert;
		};


		function getQueryParams() {
			qs = document.location.search;
			qs = qs.split('+').join(' ');
			
			var params = {},
			tokens,
			re = /[?&]?([^=]+)=([^&]*)/g;
			
			while (tokens = re.exec(qs)) {
				params[decodeURIComponent(tokens[1])] = decodeURIComponent(tokens[2]);
			}
			
			return params;
		}

		var title = getQueryParams()['title'];
		if (title) $('#title').html(title);

		function arrEquals(arr1, arr2) {
			if (!arr1 || !arr2) return arr1 == arr2;
			if (arr1.length != arr2.length) return false;

			for (var i = 0; i < arr1.length; i++) {
				if (isArray(arr1[i]) || isArray(arr2[i])) {
					if (isArray(arr1[i]) != isArray(arr2[i])) return false;

					if (!arrEquals(arr1[i], arr2[i])) return false;
				}
				else {
					if (arr1[i] != arr2[i]) return false;
				}
			}

			return true;
		}

		function isAncestor(child, ancestor) {

			child = child.parentNode;
			if (!child) return false;

			if (child == ancestor) return true;

			return isAncestor(child, ancestor);
		}

		function getCursor3() {
			var sel = window.getSelection();
	        if (sel.rangeCount > 0) {
	            var range = window.getSelection().getRangeAt(0);

	            if (!isAncestor(range.startContainer, $('#testArea')[0])) return;

	            var preCaretRange = range.cloneRange();
	            preCaretRange.selectNodeContents($('#testArea')[0]);
	            preCaretRange.setEnd(range.startContainer, range.startOffset);
	            
	            var r = [];
	            var start = range.startOffset, startContainer = range.startContainer;

	            for (var i = 0; i < 2; i++) {
		            var len = preCaretRange.toString().length;
		            var info = 0;

		            if (start == 0 || startContainer.nodeName.toLowerCase() != "#text") {
		            	info = 1;

		            	var node = previousNode(startContainer);
		            	while (node.textContent.length == 0) {
		            		node = previousNode(node);
		            		info++;
		            	}
		            }

		            r.push([len, info]);


		            preCaretRange = range.cloneRange();
		            preCaretRange.selectNodeContents($('#testArea')[0]);
		            preCaretRange.setEnd(range.endContainer, range.endOffset);
		            start = range.endOffset;
		            startContainer = range.endContainer;
		        }

	            return r;
	        }
		}

		function getCursor() {
			var sel = window.getSelection();
	        if (sel.rangeCount > 0) {
	            var range = window.getSelection().getRangeAt(0);
	            return range;
	        }
		}

		function getRange(pos) {

			var n = nodeAt(pos[0]);

			if (!n) return n;

			if (n[1] != 0) {
				for (var i = 0; i < pos[1]; i++) {
					n[0] = nextNode(n[0]);
					n[1] = 0;
				}
			}

			var nodeName = n[0].nodeName.toLowerCase();
			while (nodeName != "#text" && n[0].childNodes.length > 0) {
				n[0] = n[0].childNodes[0];
			 }

			 if (n[0].nodeName.toLowerCase() == "br") n[0] = n[0].parentNode; // can't have the cursor in a <br>

			return n;
		}

		function setCursor3(pos) {
			if (!pos) return;
			
			var start = getRange(pos[0]);
			var end = getRange(pos[1]);

			if (pos[1][0] >= pos[0][0]) {
				if (pos[1][0] > pos[0][0] || pos[1][1] > pos[0][1]) {
					var t = start;
					start = end;
					end = t;
				}
			}
			
			if (start && end) {
				var range = document.createRange();
				range.setStart(start[0], start[1]);
				range.setEnd(end[0], end[1]);
				var sel = window.getSelection();
				sel.removeAllRanges();
				sel.addRange(range);
			}

		}

		function test() { setCursor3(getCursor3()); }

		function length(el) {
			if (el.length != undefined) { return el.length; }
			if (el.innerHTML != undefined && el.innerHTML.length != undefined) { return el.innerHTML.length; }
			return 0;
		}

		var socket = io();

		var color = "";
		
		var timeOut = 100; // ms
		
		
		var oldNodes, structure, text, lastPush, lastStructure, lastText, lastChanges, preForm, from, oldCursor = [], userLookup, undefinedUsers = [], notifying = false;
		var edit, edits = {}, expecting;

		var cursorPositions = {}, lastSize;
		
		function check() {
			var el = document.getElementById("testArea");
			el.normalize();
			
			var cursor = getCursor3();
			var cursorChanged = false;


			var stuff = [strip(el), strip(nodeTree(el)), el.outerHTML];
			//console.log("preform", strip(el), strip(nodeTree(el)));
			//console.log(el.outerHTML);

			form2(el, color, false);
			form(el);

			if (!arrEquals(oldCursor, cursor)) {
				cursorChanged = true;
				oldCursor = cursor;

			}

			var element = $('#testArea')[0];

			var val = $('#testArea').html();

			if (val != oldNodes.innerHTML) {

				changes_ = getNodeChanges(oldNodes, el, cursor);
				console.log("text changes");
				console.log(changes_[1]);

				var dChanges = textChanges(oldNodes.textContent, el.textContent, el, cursor);

				if (changes_[1].length == 1) { // no changes. there is either a 1 or 0 at the end, so the minimum size is 1
					if (nodeTreesAreEqual(structure, nodeTree(el, color, true, false))) {
						for (var i = 0; i < 10; i++) console.log("html changed, but not changes");
						oldNodes.innerHTML = val;
						setTimeout(check, timeOut);
						return;
					}
				}

				console.log('------------------------------------------------');

				colorize($('#testArea')[0], dChanges, color);

				form2(el, color);
				form(el);

				from = oldNodes;
				

				lastStructure = structure.cloneNode();
				lastStructure.innerHTML = structure.innerHTML;

				lastText = text;

				var gotText = executeChanges(text, changes_[1]);

				text = getText(el);

				if (gotText != text) {
					alert('text problem');
					console.log(text);
					console.log(gotText);
				}
				preForm = getNode();
				
				//console.log("before", structureCopy.outerHTML);
				applyTextChangesToStructure(structure, getText(oldNodes), changes_[1], color, getText(el));
				form2(structure, color, true);
				form(structure);
				//console.log("after", structureCopy.outerHTML);

				oldNodes = getNode();
				lastPush = getNode();

				lastChanges = changes_;

				changes_.push(edit);

				
				

				console.log('------------------------------------------------');

				
				//console.log(changes_);
				console.log(JSON.stringify(changes_));



				var newStructure = nodeTree(el, color, true, false);
				

				if (!strippedNodeTreesAreEqual(newStructure, structure)) {
					console.log(el.outerHTML);
					console.log(nodeTree(el, color, true, false));
					alert('fail');
					console.log('problem. testArea is:');
					console.log(newStructure);
					console.log("structure");
					console.log(structure);
				}
				
				if (cursorChanged) {
					socket.emit('inp_cur', JSON.stringify([ JSON.stringify(changes_), cursor]));
				}
				else {
					socket.emit('inp', JSON.stringify(changes_));
				}
				expecting = ['resp', nextEdit(edit)];
				$('#status')[0].style.backgroundColor = "red";
			}
			else {

				if (cursorChanged) {
					socket.emit('cur', JSON.stringify(cursor));
				}

				setTimeout(check, timeOut);
			}

			var newCursor = getCursor3();
			

			if (JSON.stringify(newCursor) != JSON.stringify(cursor)) {
				setCursor3(cursor);
			}
			//setCursor3(cursor);


		}
		
		socket.on('connect', function(s) {
			documentId = getQueryParams()['doc'];
			socket.emit('init', documentId);
		});


		function nextEdit(e) {
			return (e+1)%10;
		}

		function applyPreviousEdits() {
			for (var i = nextEdit(edit); edits[i] != undefined; i = nextEdit(i)) {
				var e = edits[i];
				e['func'](e['msg']);

				edits[i] = undefined;
			}
		}

		function applyResp(msg) {
			var nodeTreeFromServer = createNodeTree(msg[1]);
			var structLen = structureLength(nodeTreeFromServer) + max(0, nodeTreeFromServer.childNodes.length - 1);
			if (structLen != msg[2].length) {
				console.log(msg[1] + " has length of " + structLen + " not " + msg[2].length);
				alert("LengthMismatch");

				var newText = msg[2];
				if (structLen > msg[2].length) {
					for (var i = 0 ; i < structLen - msg[2].length; i++) newText += " ";
				}
				else {
					newText = newText.substring(0, structLen);
				}

				socket.emit('LengthMismatch', newText);
			}

			var fromServer = createNodeTree(msg[1]);
			if ( !strippedNodeTreesAreEqual(fromServer, structure)  || msg[2] != text) {

				var pos = getCursor3();

				var got = document.createElement('div');
				got.innerHTML = msg;
				got = got.childNodes[0].innerHTML;

				socket.emit('clientError', JSON.stringify({from:from.innerHTML, to:preForm.innerHTML, afterForm:lastPush.innerHTML, got:got, change:lastChanges}));

				if (msg[2] == text) {
					console.log("structure differed");
					console.log("from server:");
					console.log(fromServer);
					console.log("from us");
					console.log(structure);

					console.log("diffs");
					var el = document.getElementById('testArea');
					console.log(structureDifferences(el, fromServer));
				}
				else {
					console.log("text differed");
					console.log("from server:");
					console.log(msg[2]);
					console.log("from us");
					console.log(text);

					console.log("diffs from us to server");
					console.log(textChanges(text, msg[2], $('#testArea')[0], pos));
				}


				$('#testArea')[0].outerHTML = msg[1];
				setText($('#testArea')[0], msg[1], msg[2]);

				form2(structure, msg[4], true);
				form(structure);


				oldNodes = getNode();
				structure = nodeTree($('#testArea')[0], color, true, false);
				text = msg[2];

				alert('difference');
				

				setCursor3(pos);
			}
		}

		socket.on('resp', function(msg){

			msg = JSON.parse(msg);

			if (expecting[0] == "resp" && expecting[1] == msg[3]) {
				//console.log("got expected");
			}
			else {
				console.log("didn't get expecting");
				console.log("expecting: " + JSON.stringify(expecting));
				console.log("got a resp with " + msg[3]);
				alert("didn't get expecting");
			}

			$('#status')[0].style.backgroundColor = "green";

			//console.log('resp ' + edit + " vs " + msg[3]);

			var next = nextEdit(edit);
			if (msg[3] != next) {
				console.log("out of order");
				edits[msg[3]] = {msg:msg, func:applyResp};
				return;
			}

			edit = msg[3];

			applyResp(msg);

			applyPreviousEdits();

			  
			text = msg[2];
			setTimeout(check, timeOut);
			expecting = ['update', nextEdit(edit)];
		});


		function applyUpdate(msg) {
			var pos = getCursor3();

			var changes_ = JSON.parse(msg[0]);
			var textChanges_ = changes_[1];

			/*var structurualChange = changes_[0];
			if (structurualChange) {
				structurualChange = [changes_[0][0], createNodeTree(changes_[0][1])];

				setStructureDifferences(structure, structurualChange);
				colorizeStructure(changes_[2], structure, msg[4]);
				form2(structure, color, true);
				form(structure);
			}

			text = executeChanges(text, textChanges_);

			if (!strippedNodeTreesAreEqual(structure, createNodeTree(msg[1])) || text != msg[2]) {
				alert('update problem');
			}*/


			//structure = nodeTree($('#testArea')[0], color, true, false);
			//text = msg[2];

			var oldText = lastText;
			lastText = executeChanges(lastText, textChanges_);
			applyTextChangesToStructure(lastStructure, oldText, textChanges_, msg[4], lastText);

			form2(lastStructure, msg[4], true);
			form(lastStructure);

			if (pos) {
				var isPost = textChanges_[textChanges_.length-1];
				for (var i = 0; i < textChanges_.length - 1; i++) {
					var change = textChanges_[i];

					for (var n = 0; n < pos.length; n++) {
						var p = pos[n];
						if (change[0] <= p[0]) {
							if (change.length == 2) {
								if (typeof change[1] == "string") {
									p[0] += change[1].length;
								}
								else {
									p[0] -= change[1];
								}
							}
							else {
								p[0] += change[1].length - change[2];
							}

							if (p[0] < change[0]) {
								p[0] = change[0];
							}
						}
					}
				}
			}
			
			

			expecting = [expecting[0], nextEdit(edit)];

			setCursor3(pos);
		}

		socket.on('update', function(msg) {			
			msg = JSON.parse(msg);

			var gotExpecting = expecting[0] == "update" && expecting[1] == msg[3];

			if (gotExpecting) {
				console.log("got expected");

				lastText = text;
				lastStructure = structure;
			}
			else {
				console.log("didn't get expecting");
				console.log("expecting " + JSON.stringify(expecting));
				console.log("got update with " + msg[3]);
				console.log(JSON.stringify(msg));
				alert("didn't get expected");
			}

			console.log('update ' + edit + " vs " + msg[3]);

			var next = nextEdit(edit);
			if (msg[3] != next) {
				edits[msg[3]] = {msg:msg, func:applyUpdate};
				return;
			}

			var el = document.getElementById("testArea");
			var changed = el.innerHTML != oldNodes.innerHTML, differences;
			console.log("changed: ", changed);

			if (changed) {
				differences = getNodeChanges(structure, el, getCursor3());
				console.log("change between inp and update");
				console.log(differences);
			}

			edit = msg[3];

			applyUpdate(msg);

			applyPreviousEdits();

			if (lastText != msg[2]) {
				console.log("updated text deosn't match");
				console.log("from server", msg[2]);
				console.log("from us    ", lastText);

				alert("updated text doesn't match");
			}

			if (!strippedNodeTreesAreEqual(lastStructure, createNodeTree(msg[1]))) {
				console.log("updated structure deosn't match");
				console.log("from server", strip(createNodeTree(msg[1])));
				console.log("from us    ", strip(lastStructure));

				alert("updated structure doesn't match");
			}


			if (!gotExpecting) {

				console.log(JSON.parse(msg[0])[1]);
				console.log("b4", JSON.stringify(lastChanges[1]));
				applyOffsets(JSON.parse(msg[0])[1], lastChanges[1]);
				console.log("after", JSON.stringify(lastChanges[1]));

				var newText = executeChanges(lastText, lastChanges[1]);
				applyTextChangesToStructure(lastStructure, lastText, lastChanges[1], color, newText);
				lastText = newText;
			}

			structure = lastStructure;
			text = lastText;

			$('#testArea')[0].outerHTML = structure.outerHTML;
			setText($('#testArea')[0], structure, text);

			oldNodes = getNode();

			console.log(text);
			console.log("done updating");

			
			// todo check for changes here, otherwise they'll be forgotten,
			// because:   changes_ = changes(old, val);
			// if there are changes, they'll have to merged
		});
		
		socket.on('init', function(msg) {
			console.log(msg);
			msg = JSON.parse(msg);
			console.log("initing with " + msg['text']);
			console.log("initing with " + msg['struct']);

			userLookup = msg['userLookup'];

			text = msg['text'];
			structure = createNodeTree(msg['struct']);
			users = msg['currentUsers'];

			var len = structureLength(structure) + max(0, structure.childNodes.length - 1);
			if (len != text.length) {
				alert('length mismatch on init');

				var newText = msg['text'];
				if (len > newText.length) {
					for (var i = 0 ; i < len - newText.length; i++) newText += " ";
				}
				else {
					newText = newText.substring(0, len);
				}

				socket.emit('LengthMismatch', newText);
			}

			edit = msg['start'];
			expecting = ['update', nextEdit(edit)];

			console.log("struct");
			console.log(structure);

			$('#testArea')[0].outerHTML = structure.outerHTML;
			setText($('#testArea')[0], structure, text);

			color = msg['color'];
			setTimeout(check, timeOut);
			
			oldNodes = getNode();
			lastPush = getNode();
			lastStructure = nodeTree(oldNodes, color, true, false);

			$('#title').html(msg['title']);

			var cursor = msg['cursor'];
			console.log(cursor);

			for (key in users) {
				if (!cursor[key]) continue;
				var data = {};
		        data[key] = cursor[key];
		        onCursorChange(data);
			}

			showUsers(users);

			$('#testArea').scroll(function (ev) {
				console.log('scroll');
				for (var key in cursorPositions) {
					var el = $('#cursor-' + key)[0];
					if (el) {
						setCursorPosition(el, cursorPositions[key][0], cursorPositions[key][1]);
					}
				}
			});
		});

		function setCursorPosition(el, left, top, height) {
			var testArea = $('#testArea')[0];
			left -= testArea.scrollLeft;
			top -=  testArea.scrollTop;
			el.style.left = left + "px";
			el.style.top  = top + "px";

			height = height || parseInt(el.childNodes[3].innerHTML);
			el.childNodes[3].innerHTML = height;

			el.childNodes[0].style.height  = height + "px";

			if (top < -height) {
				el.style.display = "none";
				el.childNodes[0].style.display = "none";
				el.childNodes[1].style.display = "none";
			}
			else if (top < 0) {
				el.style.display = "";
				el.childNodes[0].style.display = "";
				el.childNodes[1].style.display = "none";

				console.log("setting height to " + (height+top-4));
				el.style.top = "4px";
				el.childNodes[0].style.height  = (max(height+top-4, 0)) + "px";
			}
			else if (top < 4) {
				el.style.display = "";
				el.childNodes[0].style.display = "";
				el.childNodes[1].style.display = "none";
			}
			else {
				if (!lastSize) {
					el.style.display = "";
					el.childNodes[0].style.display = "";
					el.childNodes[1].style.display = "";
				}
				else {

					if (top > lastSize[1]) {
						el.style.display = "none";
						el.childNodes[0].style.display = "none";
						el.childNodes[1].style.display = "none";
					}
					else if (top > lastSize[1] - height) {
						el.style.display = "";
						el.childNodes[0].style.display = "";
						el.childNodes[1].style.display = "";
					}
					else {
						el.style.display = "";
						el.childNodes[0].style.display = "";
						el.childNodes[1].style.display = "";
					}
				}
			}
		}

		socket.on('users', function(msg) {
			msg = JSON.parse(msg);

			if (msg['added']) {
				var toAdd = msg['added'];

				if (users[toAdd]) {
					users[toAdd]['x']++;
				}
				else {
					users[toAdd] = msg['user'];
				}
			}
			if (msg['removed']) {
				var toRemove = users[msg['removed']];

				if (toRemove['x'] <= 1) {

					delete users[msg['removed']];

					var cursor = $('#cursor-' + msg['removed']);
					if (cursor.length > 0) {
						$('#cursors')[0].removeChild(cursor[0]);
					}
				}
				else {
					toRemove['x']--;
				}
			}

			showUsers(users);
		});

		socket.on('NewUserJoined', function (msg) {
			var key = Object.keys(msg)[0];

			userLookup[key] = msg[key];
		});

		function onCursorChange(msg) {
			if (!userLookup) return;

			var key = Object.keys(msg)[0];

			var cursorColor = users[key]['color'];

			var cursor = document.getElementById('cursor-' + key);

			if (!cursor) {
				cursor = $('#cursors-template-container').clone().children()[0];
				cursor.id = "cursor-" + key;

				cursor.childNodes[0].style.borderColor = cursorColor;
				cursor.childNodes[1].style.backgroundColor = cursorColor;
				cursor.childNodes[2].style.backgroundColor = cursorColor;
				cursor.childNodes[2].innerHTML = userLookup[key]['user'] || userLookup[key]['displayName'];

				$(cursor).hover(
					function() {
						this.childNodes[2].style.opacity = 1;
						this.childNodes[2].style.display = "";
						
						this.childNodes[1].style.opacity = 0;
						this.childNodes[1].style.display = "none";
						
					},

					function () {
						this.childNodes[1].style.opacity = 1;
						this.childNodes[1].style.display = "";
						
						this.childNodes[2].style.opacity = 0;
						this.childNodes[2].style.display = "none";
					}
				)

				$('#cursors')[0].appendChild(cursor);
			}

			var height = 26*.9;

			
			if (msg[key]) {
				var node = getRange(msg[key][0]);
				if (node) {
					var range = document.createRange();
					range.setStart(node[0], node[1]);
					range.setEnd(node[0], node[1]);

					var span = document.createElement("span");
					range.insertNode(span);

					var rect = span.getBoundingClientRect();

					var containerRect = $('#testArea')[0].getBoundingClientRect();

					var left = rect.left - containerRect.left + $('#testArea')[0].scrollLeft;
					var top  = rect.top - containerRect.top + $('#testArea')[0].scrollTop;

					cursorPositions[key] = [left, top];
					lastSize = [$('#testArea').width(), $('#testArea').outerHeight()];

					setCursorPosition(cursor, left, top, height);

					span.parentNode.removeChild(span);

					cursor.style.display = "";
				}
				else {
					cursor.style.display = "none";
				}
			}
			else {
				cursor.style.display = "none";
			}
		}

		socket.on('cur', onCursorChange);

		$(window).resize(function (ev) {
			if (!lastSize) return;
			return;

			var size = [$('#testArea').width() / lastSize[0], $('#testArea').outerHeight() / lastSize[1]];
			console.log(size);

			for (var key in cursorPositions) {
				var el = $('#cursor-' + key)[0];
				if (el) {
					setCursorPosition(el, (size[0] * cursorPositions[key][0]), (size[1]  * cursorPositions[key][1]));
				}
			}
		});
		
		colors = [[255, 255, 255], [255, 0, 0], [0, 255, 0], [0, 0, 255]];

		function cancelNotify(button) {
			$('#notify')[0].innerHTML = "notify";
			button.style.display = "none";
			notifying = false;
			showUsers(users);
		}

		function notify(button) {
			if (notifying) {
				button.innerHTML = "notify";
				$('#cancel')[0].style.display = "none";

				sendNotification();
			}
			else {
				button.innerHTML = "send";
				$('#cancel')[0].style.display = "";
			}

			notifying = !notifying;
			showUsers(users);
		}

		function sendNotification() {
			var lis1 = $('#leftBarUlActive')[0].childNodes;
			var lis2 = $('#leftBarUlNotActive')[0].childNodes;
			var list = [lis1, lis2];

			var ids = [];
			for (var n = 0; n < list.length; n++) {
				var lis = list[n];
				for (var i = 0; i < lis.length; i++) {
					var li = lis[i];

					var inp = li.childNodes[0];
					if (inp && inp.nodeName.toLowerCase() == "input" && inp.checked) {
						if (li.childNodes[1]) {
							var id = li.childNodes[1].id.substring(5); //5 because the id is user-3424userid234324
							ids.push(id);
						}
					}
				}
			}


			socket.emit('notify', ids);
		}

		function showUsers(users) {
			var ulActive = $('#leftBarUlActive')[0];
			var ulNotActive = $('#leftBarUlNotActive')[0];
			ulActive.innerHTML = ulNotActive.innerHTML = "";

			for (var user in userLookup) {
				var ul, color;
				
				if (users[user]) {
					var ul = ulActive;
					var color = users[user]['color'];
				}
				else {
					var ul = ulNotActive;
					var color = 'black';
				}

				var li = document.createElement('li');

				var checkbox = document.createElement('input');
				checkbox.type = 'checkbox';
				if (notifying) {
					li.appendChild(checkbox);
				}

				var font = document.createElement('font');
				font.id = "user-" + user;
				font.color = color;

				var userInfo = userLookup[user];

				if (!userInfo) {
					undefinedUsers.push(user);
					continue;
				}

				font.innerHTML = userInfo['user'] || userInfo['displayName'];
				li.appendChild(font);

				ul.appendChild(li);
			}
		}

		function removeNodesWithClass(node, className) {
			var children = node.childNodes;

			if (!children) return;

			for (var i = 0; i < children.length; i++) {
				var child = children[i];

				if (child.nodeName.toLowerCase() == "#text") continue;

				var buffered = ' ' + child.className + ' ';
				if (buffered.indexOf(className) >= 0) {
					node.removeChild(child);
					i--;
				}
				else {
					removeNodesWithClass(child, className);
				}
			}
		}

		function getNode() {
			var ta = $('#testArea');
			var node = ta[0].cloneNode();

			node.innerHTML = ta.html();

			return node;
		}

		function rename(name) {
			socket.emit('rename', name);
			$('#title').html(name);
		}
		
		
		var i = 1, options = ["rgb(121, 101, 141)", "rgb(178, 178, 178)"];
		
		$.each($('#middleBar').children(), function(o, element) {
			   element.style.backgroundColor = options[i];
			   i++;
			   i = i % options.length;
			   
			   });
			   
		$('#middleBarBack').html($('#middleBar').html());

		</script>
	
	
</html>